# 进程与线程

## 2.1_1 进程的概念,组成,特征

### 进程的概念

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211238457.png" alt="image-20220821123829539" style="zoom: 50%;" />

### 进程的组成

#### 1.`PCB`

> PCB:进程存在的唯一标志

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211244424.png" alt="image-20220821124450492" style="zoom:50%;" />

##### PCB的组成

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211248063.png" alt="image-20220821124804498" style="zoom:50%;" />

#### 2.程序段`&`数据段

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211251399.png" alt="image-20220821125133286" style="zoom:50%;" />

#### 组成总览

- 进程是`动态`的,是程序的依次执行过程
- 进程实体(进程映像)是`静态`的,是进程的一个快照(瞬间)

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211300388.png" alt="image-20220821130037094" style="zoom:50%;" />

### 进程工作流程

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211255882.png" alt="image-20220821125438916" style="zoom:50%;" />

### 进程的特征

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211310072.png" alt="image-20220821131002726" style="zoom:50%;" />

### 总结

- 在引入`线程`之前:
  - 进程是获得资源和接受调度的基本单位;
- 在引入`线程`之后:
  - 进程依然是获得资源的基本单位;
  - 线程才是接受调度的基本单位;

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211312767.png" alt="image-20220821131159353" style="zoom:50%;" />

## 2.1_2 进程的状态与转换

### 进程的状态

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211319951.png" alt="image-20220821131857310" style="zoom:50%;" />

#### 创建态`&`就绪态

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211455193.png" alt="image-20220821145332566" style="zoom:50%;" />

#### 运行态

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211459238.png" alt="image-20220821145909178" style="zoom: 50%;" />

#### 阻塞态

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211501994.png" alt="image-20220821150139710" style="zoom:50%;" />

#### 终止态

- `exit`终止进程的工作完成之后,进程彻底消失

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211503241.png" alt="image-20220821150330879" style="zoom:50%;" />

### 状态的转换

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211514260.png" alt="image-20220821151345941" style="zoom: 67%;" />

#### 基本状态

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211516925.png" alt="image-20220821151551925" style="zoom: 67%;" />

### 进程的组织

#### 1.链接方式

- `优先队列`的形式链接

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211518112.png" alt="image-20220821151812289" style="zoom:67%;" />

#### 2.索引方式

- 以`索引表`的形式链接

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208211520260.png" alt="image-20220821151943825" style="zoom:50%;" />

### 总结

![image-20220821152050371](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212005216.png)

## 2.1_3 进程控制

- `进程控制`:**实现进程状态转换**

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212004711.png" alt="image-20220821200236436"  />

### 原语实现进程控制

> 原语:操作一气呵成

![image-20220821200408430](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212004101.png)

#### Why?

- **原语可以避免信息不统一的情况**

![image-20220821200934839](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212009868.png)

### 如何实现原语

- `开关中断`实现

![image-20220821201500314](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212015320.png)

### 进程控制相关的原语

#### 1.创建原语

![image-20220821201913845](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212019817.png)

#### 2.撤销原语

![image-20220821202411332](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212024177.png)

#### 3.唤醒原语和阻塞原语

- **必须成对使用**

![image-20220821202750646](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212027247.png)

#### 4.切换原语

![image-20220821203023500](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212030227.png)

### 程序是如何运行的

![image-20220821203337398](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212033443.png)

#### 保留现场`&`恢复现场

> 切换原语:运行环境 
>
> - 指的其实就是`保存现场`
> - 保存寄存器的内容

![image-20220821204152099](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212041433.png)

![image-20220821204250711](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212042790.png)

### 总结

![image-20220821204827107](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212048517.png)

## 2.1_4 进程通信`IPC`

> IPC: 两个进程之间产生数据交互

![image-20220821205102558](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212051434.png)

###  Why操作系统支持?

![image-20220821205558617](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212055954.png)

### 类别

#### 1.共享存储

> 互斥访问:`P,V`操作

![image-20220821205941133](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212059911.png)

##### 基于数据结构`or`存储区域的共享

> - 数据结构共享:低级通信,慢
> - 存储区共享:  高级通信,快

![image-20220821210250986](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212102300.png)

#### 2.消息传递

![image-20220821210625595](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212106220.png)

##### - 直接通信

> 点名道姓的信息传递;
>
> - 发送进程id
> - 接受进程id
> - 格式化信息msg

- 发送原语

![image-20220821212110176](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212121922.png)

- 接受原语

![image-20220821212230324](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212122488.png)

- 复制`msg`

![image-20220821212428261](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212124788.png)

##### - 间接通信

> 以`信箱`为中间实体传递

- 发消息

![image-20220821213240011](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212132773.png)

- 收消息

![image-20220821213137634](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208212131550.png)

#### 3.管道通信`FIFO Pipe`

> 本质上:通道是一个`循环队列 FIFO`
>
> - 只能采用`半双工通信`,某一个时间段内只能`单向运输`
> - 如果需要`全双工通信`即实现双向同时通信,需要设置两个`管道`
> - `互斥`访问
> - 管道写满,写进程阻塞
> - 管道读空,读进程阻塞
> - `数据一旦被读出,就彻底消失`;因此当多个进程读同一个管道,可能会错乱
>   - 允许多个`写`进程,一个`读`进程(408真题)
>   - 允许多个`写`进程,多个`读`进程,,但系统让各个读进程`轮流读`数据(Linux方案)

###  总结

- 虚拟地址空间:`页表`or`段表`...

![image-20220822083949391](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220839819.png)

### 纠正

![image-20220822084345042](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220843319.png)

 

## 2.1_5 线程的概念

- `轻量级进程`

![image-20220822085851081](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220858526.png)

### `What` & `Why`

- **把执行流细化到线程可以增加并发度**
  - 进程之间可以`并发`
    - 但是在引入`线程`之前,进程内的程序代码只能串行顺序执行
    - 在引入`线程`之后,进程内部也可以让`线程`并发执行

![image-20220822090318175](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220903747.png)

### 引入线程的变化

![image-20220822091123570](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220911649.png)

### 线程的属性

![image-20220822091354650](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220913134.png)

## 2.1_6 线程实现方式`&`多线程模型

![image-20220822091819786](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220918150.png)

### 线程的实现方式

#### 1.用户级线程`ULT`

![image-20220822092408367](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220924955.png)

- 系统看不到,用户看得到

![image-20220822092700412](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220927777.png)

##### 优缺点

![image-20220822093024185](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220930099.png)

#### 2.内核级线程`KLT`

![image-20220822093706879](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220937695.png)

### 多线程模型

> 支持内核级别的系统,根据用户级线程和内核级线程的映射关系

#### 一对一模型

![image-20220822093925834](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220939771.png)

#### 多对一模型

> !!!系统只"看得见"内核级线程,只有内核级线程才是处理机分配的单位

![image-20220822094107640](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220941881.png)

#### 多对多模型

![image-20220822094617211](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208220946755.png)

## 2.1_7 线程的状态与转换

### 状态与转换

![image-20220822103634960](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221036613.png)

### 组织与控制

![image-20220822104154914](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221041578.png)

## 2.2_1 调度的概念`&`层次

![image-20220822104537273](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221045992.png)

### 调度基本概念

![image-20220822104715857](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221047258.png)

### 调度的三个层次

#### 1.高级调度--`作业调度`

![image-20220822104902790](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221049137.png)

#### 2.低级调度--`进程调度/处理机调度`

![image-20220822105244353](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221052761.png)

#### 3.中级调度--`内存调度`

![image-20220822105451138](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221054507.png)

### 进程的挂起态`&`七状态模型

> `挂起态`和`阻塞态`二者都是暂时不能获得CPU的服务
>
> - 挂起队列是进程映像在`外存`
> - 阻塞队列是进程映像在`内存`

![image-20220822110051019](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221100361.png)

### 三个层次的联系,对比

![image-20220822110413921](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221104961.png)

### 总结

![image-20220822110521538](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221105845.png)

## 2.2_2 进程调度的时机,切换与过程,方式

![image-20220822150931292](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221509804.png)

### 进程调度的时机

![image-20220822152216384](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221522951.png)

#### 内核程序临界区和临界区的区别

> 本质上:
>
> - 普通临界区的访问不会直接影响到OS内核的管理工作,因此在访问普通临界区可以进行调度与切换
> - 内核程序临界区:如果不尽快释放,极可能影响到OS内核调度管理工作,因此不可以调度与切换

![image-20220822151856838](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221518131.png)

### 进程调度的方式

- 抢占式
- 非抢占式

![image-20220822152412005](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221524424.png)

### 进程的切换与过程

![image-20220822152550251](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221526233.png)

### 总结

![image-20220822153025976](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208221530929.png)