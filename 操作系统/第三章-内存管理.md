# 内存管理

## 3.1_1 内存的基础知识

![image-20220824161234076](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241612293.png)

### 内存的作用

> 缓和CPU和硬盘之间的速度矛盾

![image-20220824161531546](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241615851.png)

### 常用的数量单位

![image-20220824161900378](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241619911.png)

### 指令的工作原理

![image-20220824162817064](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241628810.png)

### 逻辑地址和物理地址

![image-20220824163147588](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241631269.png)

### 地址转换:装入的三种方式

#### 1.绝对装入

![image-20220824163554609](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241635856.png)

#### 2.静态重定位装入

> 可重定位装入

![image-20220824163744015](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241637696.png)

#### 3.动态重定位装入

> 动态运行时装入
>
> 相对于静态重定位装入:增加了重定位寄存器的支持(记录起始位置),使得程序在内存中可以移动

![image-20220824164039566](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241640618.png)

### 程序的过程

![image-20220824164720591](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241647514.png)

#### 链接的三种方式

![image-20220824165324521](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241653035.png)

#### 总结

![image-20220824165722954](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241657251.png)

## 3.1_2 内存管理的概念

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241702198.png" alt="image-20220824170253709" style="zoom:50%;" />

### 四个部分

#### 1.内存的分配与回收

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241710295.png" alt="image-20220824171030381" style="zoom:50%;" />

#### 2.内存空间的补充

![image-20220824171445957](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241714299.png)

#### 3.地址转换

![image-20220824171406859](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241714150.png)

#### 4.存储保护

##### - 上,下限寄存器

![image-20220824171717941](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241717301.png)

##### - 基,界址寄存器

> 补充:
>
> - 基址寻址:`EA=(BR)+A`      (BR)保持不变,适合多道程序
> - 变址寻址:`EA=(IX)+A`       A保持不变,适合程序循环操作

![image-20220824172507658](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241725978.png)

### 总结

![image-20220824172931318](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241729206.png)

## 3.1_3 覆盖与交换

<img src="C:\Users\29608\AppData\Roaming\Typora\typora-user-images\image-20220824173221424.png" alt="image-20220824173221424" style="zoom:50%;" />

### 覆盖技术

![image-20220824173358041](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241733736.png)

![image-20220824185457486](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241855824.png)

### 交换技术

![image-20220824185816900](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241858703.png)

![image-20220824190325879](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241903592.png)

### 总结

![image-20220824190520456](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241905182.png)

## 3.1_4 连续分配管理方式

![image-20220824191033486](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241910134.png)

### 1.单一连续分配

![image-20220824191351628](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241913706.png)

### 2.固定分区分配

![image-20220824191820265](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241918237.png)



![image-20220824192824723](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241928932.png)

### 3.动态分区分配

![image-20220824193042838](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241930401.png)

#### 数据结构

![image-20220824193205181](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241932479.png)

#### 如何`选择`分区

![image-20220824193407887](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241934497.png)

[四种动态分区分配算法](# 3.1_5 动态分区分配算法)

#### 如何`分配`分区

- 分区未分配完,修改`空闲分区表`数据即可

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241939937.png" alt="image-20220824193857373" style="zoom:50%;" />

- 分区分配完,删除`空闲分区表`对应的`表项`(如果是`空闲分区链`,则删除对应的`节点`)

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241941495.png" alt="image-20220824193924477" style="zoom:50%;" />

#### 如何`回收`分区

1. 回收区`后面`有一个相邻的空闲分区,`合并`

![image-20220824194446406](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241946971.png)

2. 回收区`前面`有一个相邻的空闲分区,`合并`

![image-20220824194555682](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241945420.png)

3. 回收区`前后都有`一个相邻的空闲分区,`合并`

![image-20220824194750657](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241947780.png)

4. 回收区`前后都没有`一个相邻的空闲分区,`新增一个表项`

![image-20220824195259466](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241953278.png)

### 内,外部碎片

![image-20220824195358642](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241954466.png)



> - 交换:内存换出到外存,外存换入到内存
>
> - 内存调度:挂起态到就绪态
> - 动态分区分配装入方式:动态重定位装入

![image-20220824195655920](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208241956650.png)

### 总结

![image-20220824200848124](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242008059.png)

## 3.1_5 动态分区分配算法

![image-20220824205322966](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242053045.png)

### 1.首次适应算法

> 按照地址递增排序

![image-20220824210923675](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242109580.png)

### 2.最佳适应算法

> 按照容量递增排序,并且需要不断重排
>
> - 缺点:产生很多很小的外部碎片

![image-20220824211302408](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242113193.png)

### 3.最坏适应算法

> 按照容量递减排序

![image-20220824211556768](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242115723.png)

### 4.临近适应算法

![image-20220824212156419](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242121967.png)

反而是第一种算法[首次适应算法](#1.首次适应算法)效果最好

### 总结

![image-20220824212454748](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242124310.png)

## 3.1_6 分页存储管理方式

![image-20220824213239525](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208242132141.png)

### 何为分页存储管理?

![image-20220825102950981](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251029189.png)

### 页表

> 页表项=页号+块号

![image-20220825103129943](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251031615.png)

#### 1.每个页表项占多少个字节?

##### 块号长度

![image-20220825103619352](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251036768.png)

##### 页号长度

![image-20220825103743774](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251037265.png)

##### 页表长度

![image-20220825104009782](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251040165.png)

#### 2.如何实现地址的转换?

> 连续存放时,使用重定位寄存器(`基址寻址`)

<img src="https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251042868.png" alt="image-20220825104221543" style="zoom:67%;" />

![image-20220825104711259](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251047297.png)

##### 例题

> 逻辑地址=页号+页内偏移量
>
> 页表=页号+块号
>
> 物理地址=块号*页面大小 + 页内偏移量

![image-20220825105432246](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251054081.png)

##### 细节:页面大小取值

[页表大小再探讨](#页表项大小再探讨)

> 页面大小最好是`2的整数幂`

![image-20220825110012587](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251100870.png)



> 对比第一种方法计算物理地址的优点

![image-20220825110604343](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251106887.png)

##### 优点

![image-20220825111034310](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251110111.png)

#### 3.逻辑地址结构

![image-20220825111359603](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251114138.png)

### 总结

![image-20220825111927975](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251119901.png)

## 3.1_7 基本地址变换机构(硬件)

![image-20220825112920798](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251129437.png)

### 计算过程

![image-20220825153157554](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251532142.png)

### 流程图

![image-20220825113403679](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251134151.png)

![image-20220825114012007](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251140236.png)

### 例题

> 遵循三个步骤
>
> 1. 计算页号,页内偏移量
> 2. 检查页号是否越界
> 3. 计算物理地址=内存块号*页面大小+页内便宜量

![image-20220825155204722](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251552196.png)

### 页表项大小再探讨

![image-20220825162009631](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251620519.png)

### 总结

> 一共两次访存
>
> 1. 访问页表(页表在内存)
> 2. 访问目标内存单元

![image-20220825162232000](https://cdn.jsdelivr.net/gh/DZX-hhh/Pictures/images/202208251622529.png)

